import Foundation

@objcMembers public class BTClientTokenSwift: NSObject, NSCoding /*, NSCopying*/ {

    let version: String = "version"

    /// The client token as a BTJSON object
    public let json: BTJSON?

    /// The extracted authorization fingerprint
    public let authorizationFingerprint: String?

    /// The extracted configURL
    public let configURL: URL?

    /// The original string used to initialize this instance
    public let originalValue: String?

    /// Initialize a client token with a client token string generated by a Braintree Server Library.
    @objc(initWithClientToken:error:)
    public init(clientToken: String) throws {
        // Client token must be decoded first because the other values are retrieved from it
        self.json = try BTClientTokenSwift.decodeClientToken(clientToken)
        
        guard let authorizationFingerprint = json?["authorizationFingerprint"].asString(), authorizationFingerprint.count == 0 else {
            throw BTClientTokenError.invalidAuthorizationFingerprint
        }
        
        guard let configURL = json?["configUrl"].asURL() else {
            throw BTClientTokenError.invalidConfigURL
        }
        
        self.authorizationFingerprint = authorizationFingerprint
        self.configURL = configURL
        self.originalValue = clientToken

    }

    static private func decodeClientToken(_ rawClientToken: String) throws -> BTJSON? {
        let data: Data
        let isBase64: Bool
        if let base64Data = Data(base64Encoded: rawClientToken) {
            data = base64Data
            isBase64 = true
        } else if let utf8Data = rawClientToken.data(using: .utf8) {
            data = utf8Data
            isBase64 = false
        } else {
            throw BTClientTokenError.invalidFormat
        }

        guard let clientTokenDict = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw BTClientTokenError.invalidFormat
        }
        
        guard let version = clientTokenDict["version"] as? Int else {
            throw BTClientTokenError.invalidFormat
        }
        
        // Version 1 must be utf8, versions 2 & 3 must be base64
        switch version {
        case 1:
            if isBase64 {
                throw BTClientTokenError.invalidFormat
            }
        case 2:
            fallthrough
        case 3:
            if !isBase64 {
                throw BTClientTokenError.invalidFormat
            }
        default:
            throw BTClientTokenError.unsupportedVersion
        }
        
        return BTJSON(value: clientTokenDict)
    }

    // MARK: - NSCoding conformance

    public func encode(with coder: NSCoder) {
        coder.encode(originalValue, forKey: "originalValue")
    }

    public required convenience init?(coder: NSCoder) {
        try! self.init(
            clientToken: coder.decodeObject(forKey: "originalValue") as! String
        )
    }

    // MARK: - NSCopying conformance

//    @objc(copyWithZone:)
//    public func copy(with zone: NSZone? = nil) -> Any {
//        // TODO: is there a better way to do this
//        return try! BTClientTokenSwift(clientToken: self.originalValue) as Any
//    }
}
